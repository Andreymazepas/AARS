# Copyright (c) 2003-2010,  Pete Sanderson and Kenneth Vollmar
#
# Developed by Pete Sanderson (psanderson@otterbein.edu)
# and Kenneth Vollmar (kenvollmar@missouristate.edu)
#
# Permission is hereby granted, free of charge, to any person obtaining 
# a copy of this software and associated documentation files (the 
# "Software"), to deal in the Software without restriction, including 
# without limitation the rights to use, copy, modify, merge, publish, 
# distribute, sublicense, and/or sell copies of the Software, and to 
# permit persons to whom the Software is furnished to do so, subject 
# to the following conditions:
#
# The above copyright notice and this permission notice shall be 
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR 
# ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF 
# CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION 
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# (MIT license, http://www.opensource.org/licenses/mit-license.html)


# File containing definitions of MIPS pseudo-ops

# File format:
#   Each line contains specification for one pseudo-op, including optional description.
#   First item is source statement syntax, specified in same "example" parser format used for regular instructions.
#   Source statement specification ends with a tab.  It is followed by a tab-separated list of basic instruction
#   templates to complete and substitute for the pseudo-op.
#   Format for specifying syntax of templates is different from specifying syntax of source statement:
#      (n=0,1,2,3,...) is token position in source statement (operator is token 0, parentheses are tokens but commas aren't)
#      RGn means substitute register found in n'th token of source statement
#      NRn means substitute next higher register than the one in n'th token of source code
#      OPn means substitute n'th token of source code as is
#      LLn means substitute low order 16-bits from label address in source token n.
#      LLnU means substitute low order 16-bits (unsigned) from label address in source token n.
#      LLnPm (m=1,2,3,4) means substitute low order 16-bits from label address in source token n, after adding m.
#      LHn means substitute high order 16-bits from label address in source token n. Must add 1 if address bit 15 is 1. 
#      LHnPm (m=1,2,3,4) means substitute high order 16-bits from label address in source token n, after adding m. Must then add 1 if bit 15 is 1. 
#      VLn means substitute low order 16-bits from 32-bit value in source token n.
#      VLnU means substitute low order 16-bits (unsigned) from 32-bit value in source token n.
#      VLnPm (m=1,2,3,4) means substitute low order 16-bits from 32-bit value in source token n, after adding m to value.
#      VLnPmU (m=1,2,3,4) means substitute low order 16-bits(unsigned) from 32-bit value in source token n, after adding m to value.
#      VHLn means substitute high order 16-bits from 32-bit value in source token n.  Use this if later combined with low order 16-bits using "ori X1,X1,VLnU". See logical and branch operations.
#      VHn means substitute high order 16-bits from 32-bit value in source token n, then add 1 if value's bit 15 is 1.  Use this only if later instruction uses VLn(X1) to calculate 32-bit address.  See loads and stores.
#      VHLnPm (m=1,2,3,4) means substitute high order 16-bits from 32-bit value in source token n, after adding m.  See VHLn.
#      VHnPm (m=1,2,3,4) means substitute high order 16-bits from 32-bit value in source token n, after adding m. Must then add 1 if bit 15 is 1. See VHn.
#      LLP is similar to LLn, but is needed for "label+100000" address offset. Immediate is added before taking low order 16. 
#      LLPU is similar to LLn, but is needed for "label+100000" address offset. Immediate is added before taking low order 16 (unsigned). 
#      LLPPm (m=1,2,3,4) is similar to LLP except m is added along with immediate before taking low order 16. 
#      LHPA is similar to LHn, but is needed for "label+100000" address offset. Immediate is added before taking high order 16.
#      LHPN is similar to LHPA, used only by "la" instruction. Address resolved by "ori" so do not add 1 if bit 15 is 1.
#      LHPAPm (m=1,2,3,4) is similar to LHPA except value m is added along with immediate before taking high order 16.
#      LHL means substitute high order 16-bits from label address in token 2 of "la" (load address) source statement.
#      LAB means substitute textual label from last token of source statement.  Used for various branches.
#      S32 means substitute the result of subtracting the constant value in last token from 32.  Used by "ror", "rol".
#      DBNOP means Delayed Branching NOP - generate a "nop" instruction but only if delayed branching is enabled.  Added in 3.4.1 release.
#      BROFFnm means substitute n if delayed branching is NOT enabled otherwise substitute m.  n and m are single digit numbers indicating constant branch offset (in words).  Added in 3.4.1 release.
#      COMPACT is a marker to separate the default template from a second template optimized for 16-bit addresses.  See loads and stores having (data) label operands.
#   Everything else is copied as is into the generated statement (you must use register numbers not mnemonics)
#   The list of basic instruction templates is optionally followed a description of the instruction for help purposes.
#   To add optional description, append a tab then the '#' character followed immediately (no spaces) by the description.
#
#  See documentation for ExtendedInstruction.makeTemplateSubstitutions() for more details.
#
#  Matching for a given instruction mnemonic is first-fit not best-fit.  If an instruction has both 16 and 32-bit
#  immediate operand options, they should be listed in that order (16-bit version first).  Otherwise the 16-bit
#  version will never be matched since the 32-bit version fits small immediate values first.
#
#  The pseudo-op specification must start in the first column.  If first column is blank, the line will be skipped!
#
#  When specifying the example instruction (first item on line), the conventions I follow are:
#  - for a register operand, specify a numbered register (e.g. X1 or X1) to represent any register in the set. 
#    The numerical value is not significant.  This is NOT the case when writing the templates that follow!
#    In the templates, numbered registers are parsed as is (use only X0 and X1, which are $zero and $at).
#  - for an immediate operand, specify a positive value indicative of the expected range.  I use 10 to represent
#    a 5 bit value, 100 to represent a 16-bit value, and 100000 to represent a 32-bit value.
#  - for a label operand, I use the string "label" (without the quotes). 
#  The idea is to give the parser an example that will be parsed into the desired token sequence.  Syntax checking
#  is done by comparing the source token sequence to list of token sequences generated from the examples.
#  IMPORTANT NOTE:  The use of X1,X2, etc in the instruction sample means that any CPU register reference
#                   can be used in that position.  It is simply a placeholder.  By contrast, when
#                   X1 is used in the template specification, X1 ($at) is literally placed into the generated
#                   instruction!  If you want the generated code to echo the source register, use RG1,RG2, etc.

#######################  arithmetic and branch pseudo-ops #####################

not X1,X2	nor RG1, RG2, X0	#Bitwise NOT (bit inversion)

# Here are some "convenience" arithmetic pseduo-ops.  But do they encourage sloppy programming?
add X1,X2,-100	addi RG1, RG2, VL3	#ADDition : set X1 to (X2 plus 16-bit immediate)
add X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	add RG1, RG2, X1	#ADDition : set X1 to (X2 plus 32-bit immediate)
addu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	addu RG1, RG2, X1	#ADDition Unsigned : set X1 to (X2 plus 32-bit immediate), no overflow
addi X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	add RG1, RG2, X1	#ADDition Immediate : set X1 to (X2 plus 32-bit immediate)
addiu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	addu RG1, RG2, X1	#ADDition Immediate Unsigned: set X1 to (X2 plus 32-bit immediate), no overflow
sub X1,X2,-100		addi X1, X0, VL3	sub RG1, RG2, X1	#SUBtraction : set X1 to (X2 minus 16-bit immediate)
sub X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	sub RG1, RG2, X1	#SUBtraction : set X1 to (X2 minus 32-bit immediate)
subu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	subu RG1, RG2, X1	#SUBtraction Unsigned : set X1 to (X2 minus 32-bit immediate), no overflow
subi X1,X2,-100		addi X1, X0, VL3	sub RG1, RG2, X1	#SUBtraction Immediate : set X1 to (X2 minus 16-bit immediate)
subi X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	sub RG1, RG2, X1	#SUBtraction Immediate : set X1 to (X2 minus 32-bit immediate)
subiu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	subu RG1, RG2, X1	#SUBtraction Immediate Unsigned : set X1 to (X2 minus 32-bit immediate), no overflow
# feel free to add more convenience arithmetic pseduo-ops.

# convenience logical operations can be added too,
andi X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	and RG1, RG2, X1	#AND Immediate : set X1 to (X2 bitwise-AND 32-bit immediate)
ori X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	or RG1, RG2, X1		#OR Immediate : set X1 to (X2 bitwise-OR 32-bit immediate)
xori X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	xor RG1, RG2, X1	#XOR Immediate : set X1 to (X2 bitwise-exclusive-OR 32-bit immediate)
and X1,X2,100	andi RG1, RG2, VL3U	#AND : set X1 to (X2 bitwise-AND 16-bit unsigned immediate)
or X1,X2,100	ori RG1, RG2, VL3U	#OR : set X1 to (X2 bitwise-OR 16-bit unsigned immediate)
xor X1,X2,100	xori RG1, RG2, VL3U	#XOR : set X1 to (X2 bitwise-exclusive-OR 16-bit unsigned immediate)
and X1,100	andi RG1, RG1, VL2U	#AND : set X1 to (X1 bitwise-AND 16-bit unsigned immediate)
or X1,100	ori RG1, RG1, VL2U	#OR : set X1 to (X1 bitwise-OR 16-bit unsigned immediate)
xor X1,100	xori RG1, RG1, VL2U	#XOR : set X1 to (X1 bitwise-exclusive-OR 16-bit unsigned immediate)
andi X1,100	andi RG1, RG1, VL2U	#AND Immediate : set X1 to (X1 bitwise-AND 16-bit unsigned immediate)
ori X1,100	ori RG1, RG1, VL2U	#OR Immediate : set X1 to (X1 bitwise-OR 16-bit unsigned immediate)
xori X1,100	xori RG1, RG1, VL2U	#XOR Immediate : set X1 to (X1 bitwise-exclusive-OR 16-bit unsigned immediate)
andi X1,100000	lui X1, VHL2	ori X1, X1, VL2U	and RG1, RG1, X1	#AND Immediate : set X1 to (X1 bitwise-AND 32-bit immediate)
ori X1,100000	lui X1, VHL2	ori X1, X1, VL2U	or RG1, RG1, X1	#OR Immediate : set X1 to (X1 bitwise-OR 32-bit immediate)
xori X1,100000	lui X1, VHL2	ori X1, X1, VL2U	xor RG1, RG1, X1	#XOR Immediate : set X1 to (X1 bitwise-exclusive-OR 32-bit immediate)

# Note: most of the expansions in this group were rewritten for Release 3.4.1 to remove internal branching.
seq X1,X2,X3	subu RG1, RG2, RG3	ori X1, X0, 1	sltu RG1, RG1, X1	#Set EQual : if X2 equal to X3 then set X1 to 1 else 0
seq X1,X2,-100	addi X1, X0, VL3	subu RG1, RG2, X1	ori X1, X0, 1	sltu RG1, RG1, X1	#Set EQual : if X2 equal to 16-bit immediate then set X1 to 1 else 0
seq X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	subu RG1, RG2, X1	ori X1, X0, 1	sltu RG1, RG1, X1	#Set EQual : if X2 equal to 32-bit immediate then set X1 to 1 else 0

sne X1,X2,X3	subu RG1, RG2, RG3	sltu RG1, X0, RG1	#Set Not Equal : if X2 not equal to X3 then set X1 to 1 else 0
sne X1,X2,-100	addi X1, X0, VL3	subu RG1, RG2, X1	sltu RG1, X0, RG1	#Set Not Equal : if X2 not equal to 16-bit immediate then set X1 to 1 else 0
sne X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	subu RG1, RG2, X1	sltu RG1, X0, RG1	#Set Not Equal : if X2 not equal to 32-bit immediate then set X1 to 1 else 0

sge X1,X2,X3	slt RG1, RG2, RG3	ori X1, X0, 1	subu RG1, X1, RG1	#Set Greater or Equal : if X2 greater or equal to X3 then set X1 to 1 else 0
sge X1,X2,-100	addi X1, X0, VL3	slt RG1, RG2, X1	ori X1, X0, 1	subu RG1, X1, RG1	#Set Greater or Equal : if X2 greater or equal to 16-bit immediate then set X1 to 1 else 0
sge X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	slt RG1, RG2, X1	ori X1, X0, 1	subu RG1, X1, RG1	#Set Greater or Equal : if X2 greater or equal to 32-bit immediate then set X1 to 1 else 0

sgeu X1,X2,X3	sltu RG1, RG2, RG3	ori X1, X0, 1	subu RG1, X1, RG1	#Set Greater or Equal Unsigned : if X2 greater or equal to X3 (unsigned compare) then set X1 to 1 else 0
sgeu X1,X2,-100	addi X1, X0, VL3	sltu RG1, RG2, X1	ori X1, X0, 1	subu RG1, X1, RG1	#Set Greater or Equal Unsigned : if X2 greater or equal to 16-bit immediate (unsigned compare) then set X1 to 1 else 0
sgeu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	sltu RG1, RG2, X1	ori X1, X0, 1	subu RG1, X1, RG1	#Set Greater or Equal Unsigned : if X2 greater or equal to 32-bit immediate (unsigned compare) then set X1 to 1 else 0

sgt X1,X2,X3	slt RG1, RG3, RG2	#Set Greater Than : if X2 greater than X3 then set X1 to 1 else 0
sgt X1,X2,-100	addi X1, X0, VL3	slt RG1, X1, RG2	#Set Greater Than : if X2 greater than 16-bit immediate then set X1 to 1 else 0
sgt X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	slt RG1, X1, RG2	#Set Greater Than : if X2 greater than 32-bit immediate then set X1 to 1 else 0

sgtu X1,X2,X3	sltu RG1, RG3, RG2	#Set Greater Than Unsigned : if X2 greater than X3 (unsigned compare) then set X1 to 1 else 0
sgtu X1,X2,-100	addi X1, X0, VL3	sltu RG1, X1, RG2	#Set Greater Than Unsigned : if X2 greater than 16-bit immediate (unsigned compare) then set X1 to 1 else 0
sgtu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	sltu RG1, X1, RG2	#Set Greater Than Unsigned : if X2 greater than 32-bit immediate (unsigned compare) then set X1 to 1 else 0

sle X1,X2,X3	slt RG1, RG3, RG2	ori X1, X0, 1	subu RG1, X1, RG1	#Set Less or Equal : if X2 less or equal to X3 then set X1 to 1 else 0
sle X1,X2,-100	addi X1, X0, VL3	slt RG1, X1, RG2	ori X1, X0, 1	subu RG1, X1, RG1	#Set Less or Equal : if X2 less or equal to 16-bit immediate then set X1 to 1 else 0
sle X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	slt RG1, X1, RG2	ori X1, X0, 1	subu RG1, X1, RG1	#Set Less or Equal : if X2 less or equal to 32-bit immediate then set X1 to 1 else 0

sleu X1,X2,X3	sltu RG1, RG3, RG2	ori X1, X0, 1	subu RG1, X1, RG1	#Set Less or Equal Unsigned: if X2 less or equal to X3 (unsigned compare) then set X1 to 1 else 0
sleu X1,X2,-100	addi X1, X0, VL3	sltu RG1, X1, RG2	ori X1, X0, 1	subu RG1, X1, RG1	#Set Less or Equal Unsigned: if X2 less or equal to 16-bit immediate (unsigned compare) then set X1 to 1 else 0
sleu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	sltu RG1, X1, RG2	ori X1, X0, 1	subu RG1, X1, RG1	#Set Less or Equal Unsigned: if X2 less or equal to 32-bit immediate (unsigned compare) then set X1 to 1 else 0


move X1,X2	addu RG1, X0, RG2	#MOVE : Set X1 to contents of X2
abs X1,X2	sra X1, RG2, 31	xor RG1, X1, RG2	subu RG1, RG1, X1	#ABSolute value : Set X1 to absolute value of X2 (algorithm from Hacker's Delight) 
neg X1,X2	sub RG1, X0, RG2	#NEGate : Set X1 to negation of X2
negu X1,X2	subu RG1, X0, RG2	#NEGate Unsigned : Set X1 to negation of X2, no overflow

b label	bgez X0, LAB	#Branch : Branch to statement at label unconditionally
beqz X1,label	beq RG1, X0, LAB	#Branch if EQual Zero : Branch to statement at label if X1 is equal to zero
bnez X1,label	bne RG1, X0, LAB	#Branch if Not Equal Zero : Branch to statement at label if X1 is not equal to zero

beq X1,-100,label	addi X1, X0, VL2	beq X1, RG1, LAB	#Branch if EQual : Branch to statement at label if X1 is equal to 16-bit immediate
beq X1,100000,label	lui X1, VHL2	ori X1, X1, VL2U	beq X1, RG1, LAB	#Branch if EQual : Branch to statement at label if X1 is equal to 32-bit immediate	
bne X1,-100,label	addi X1, X0, VL2	bne X1, RG1, LAB	#Branch if Not Equal : Branch to statement at label if X1 is not equal to 16-bit immediate
bne X1,100000,label	lui X1, VHL2	ori X1, X1, VL2U	bne X1, RG1, LAB	#Branch if Not Equal : Branch to statement at label if X1 is not equal to 32-bit immediate	

bge X1,X2,label	slt X1, RG1, RG2	beq X1, X0, LAB	#Branch if Greater or Equal : Branch to statement at label if X1 is greater or equal to X2
bge X1,-100,label	slti X1, RG1, VL2	beq X1, X0, LAB	#Branch if Greater or Equal : Branch to statement at label if X1 is greater or equal to 16-bit immediate	
bge X1,100000,label	lui X1, VHL2	ori X1, X1, VL2U	slt X1, RG1, X1	beq X1, X0, LAB	#Branch if Greater or Equal : Branch to statement at label if X1 is greater or equal to 32-bit immediate	

bgeu X1,X2,label	sltu X1, RG1, RG2	beq X1, X0, LAB	#Branch if Greater or Equal Unsigned : Branch to statement at label if X1 is greater or equal to X2 (unsigned compare)
bgeu X1,-100,label	sltiu X1, RG1, VL2	beq X1, X0, LAB	#Branch if Greater or Equal Unsigned : Branch to statement at label if X1 is greater or equal to 16-bit immediate (unsigned compare)
bgeu X1,100000,label	lui X1, VHL2	ori X1, X1, VL2U	sltu X1, RG1, X1	beq X1, X0, LAB	#Branch if Greater or Equal Unsigned : Branch to statement at label if X1 is greater or equal to 32-bit immediate (unsigned compare)

bgt X1,X2,label	slt X1, RG2, RG1	bne X1, X0, LAB	#Branch if Greater Than : Branch to statement at label if X1 is greater than X2
bgt X1,-100,label	addi X1, X0, VL2	slt X1, X1, RG1	bne X1, X0, LAB	#Branch if Greater Than : Branch to statement at label if X1 is greater than 16-bit immediate	
bgt X1,100000,label	lui X1, VHL2P1	ori X1, X1, VL2P1U	slt X1, RG1, X1	beq X1, X0, LAB	#Branch if Greater Than : Branch to statement at label if X1 is greater than 32-bit immediate

bgtu X1,X2,label	sltu X1, RG2, RG1	bne X1, X0, LAB	#Branch if Greater Than Unsigned: Branch to statement at label if X1 is greater than X2 (unsigned compare)
bgtu X1,-100,label	addi X1, X0, VL2	sltu X1, X1, RG1	bne X1, X0, LAB	#Branch if Greater Than Unsigned: Branch to statement at label if X1 is greater than 16-bit immediate (unsigned compare)
bgtu X1,100000,label	lui X1, VHL2	ori X1, X1, VL2U	sltu X1, X1, RG1	bne X1, X0, LAB	#Branch if Greater Than Unsigned: Branch to statement at label if X1 is greater than 16-bit immediate (unsigned compare)

ble X1,X2,label	slt X1, RG2, RG1	beq X1, X0, LAB	#Branch if Less or Equal : Branch to statement at label if X1 is less than or equal to X2
ble X1,-100,label	addi X1, RG1, -1	slti X1, X1, VL2	bne X1, X0, LAB	#Branch if Less or Equal : Branch to statement at label if X1 is less than or equal to 16-bit immediate
ble X1,100000,label	lui X1, VHL2P1	ori X1, X1, VL2P1U	slt X1, RG1, X1	bne X1, X0, LAB	#Branch if Less or Equal : Branch to statement at label if X1 is less than or equal to 32-bit immediate	

bleu X1,X2,label	sltu X1, RG2, RG1	beq X1, X0, LAB	#Branch if Less or Equal Unsigned : Branch to statement at label if X1 is less than or equal to X2 (unsigned compare)
bleu X1,-100,label	addi X1, X0, VL2	sltu X1, X1, RG1	beq X1, X0, LAB	#Branch if Less or Equal Unsigned : Branch to statement at label if X1 is less than or equal to 16-bit immediate (unsigned compare)
bleu X1,100000,label	lui X1, VHL2	ori X1, X1, VL2U	sltu X1, X1, RG1	beq X1, X0, LAB	#Branch if Less or Equal Unsigned : Branch to statement at label if X1 is less than or equal to 32-bit immediate (unsigned compare)

blt X1,X2,label	slt X1, RG1, RG2	bne X1, X0, LAB	#Branch if Less Than : Branch to statement at label if X1 is less than X2
blt X1,-100,label	slti X1, RG1, VL2	bne X1, X0, LAB	#Branch if Less Than : Branch to statement at label if X1 is less than 16-bit immediate
blt X1,100000,label	lui X1, VHL2	ori X1, X1, VL2U	slt X1, RG1, X1	bne X1, X0, LAB	#Branch if Less Than : Branch to statement at label if X1 is less than 32-bit immediate

bltu X1,X2,label	sltu X1, RG1, RG2	bne X1, X0, LAB	#Branch if Less Than Unsigned : Branch to statement at label if X1 is less than X2
bltu X1,-100,label	sltiu X1, RG1, VL2	bne X1, X0, LAB	#Branch if Less Than Unsigned : Branch to statement at label if X1 is less than 16-bit immediate	
bltu X1,100000,label	lui X1, VHL2	ori X1, X1, VL2U	sltu X1, RG1, X1	bne X1, X0, LAB	#Branch if Less Than Unsigned : Branch to statement at label if X1 is less than 32-bit immediate

rol X1,X2,X3	subu X1, X0, RG3	srlv X1, RG2, X1	sllv RG1, RG2, RG3	or RG1, RG1, X1	#ROtate Left : Set X1 to (X2 rotated left by number of bit positions specified in X3)
rol X1,X2,10	srl X1, RG2, S32	sll RG1, RG2, OP3	or RG1, RG1, X1	#ROtate Left : Set X1 to (X2 rotated left by number of bit positions specified in 5-bit immediate)
ror X1,X2,X3	subu X1, X0, RG3	sllv X1, RG2, X1	srlv RG1, RG2, RG3	or RG1, RG1, X1	#ROtate Right : Set X1 to (X2 rotated right by number of bit positions specified in X3)
ror X1,X2,10	sll X1, RG2, S32	srl RG1, RG2, OP3	or RG1, RG1, X1	#ROtate Right : Set X1 to (X2 rotated right by number of bit positions specified in 5-bit immediate)

mfc1.d X1,X2	mfc1 RG1, RG2	mfc1 NR1, NR2	#Move From Coprocessor 1 Double : Set X1 to contents of X2, set next higher register from X1 to contents of next higher register from X2
mtc1.d X1,X2	mtc1 RG1, RG2	mtc1 NR1, NR2	#Move To Coprocessor 1 Double : Set X2 to contents of X1, set next higher register from X2 to contents of next higher register from X1

mul X1,X2,-100	addi X1, X0, VL3	mul RG1, RG2, X1	#MULtiplication : Set HI to high-order 32 bits, LO and X1 to low-order 32 bits of the product of X2 and 16-bit signed immediate (use mfhi to access HI, mflo to access LO)
mul X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	mul RG1, RG2, X1	#MULtiplication : Set HI to high-order 32 bits, LO and X1 to low-order 32 bits of the product of X2 and 32-bit immediate (use mfhi to access HI, mflo to access LO)
mulu X1,X2,X3	multu RG2, RG3	mflo RG1	#MULtiplication Unsigned : Set HI to high-order 32 bits, LO and X1 to low-order 32 bits of (X2 multiplied by X3, unsigned multiplication)
mulu X1,X2,-100	addi X1, X0, VL3	multu RG2, X1	mflo RG1	#MULtiplication Unsigned :  Set HI to high-order 32 bits, LO and X1 to low-order 32 bits of (X2 multiplied by 16-bit immediate, unsigned multiplication)
mulu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	multu RG2, X1	mflo RG1	#MULtiplication Unsigned :  Set HI to high-order 32 bits, LO and X1 to low-order 32 bits of (X2 multiplied by 32-bit immediate, unsigned multiplication)
mulo X1,X2,X3	mult RG2, RG3	mfhi X1	mflo RG1	sra RG1, RG1, 31	beq X1, RG1, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow : Set X1 to low-order 32 bits of the product of X2 and X3
mulo X1,X2,-100	addi X1, X0, VL3	mult RG2, X1	mfhi X1	mflo RG1	sra RG1, RG1, 31	beq X1, RG1, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow : Set X1 to low-order 32 bits of the product of X2 and signed 16-bit immediate
mulo X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	mult RG2, X1	mfhi X1	mflo RG1	sra RG1, RG1, 31	beq X1, RG1, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow : Set X1 to low-order 32 bits of the product of X2 and 32-bit immediate
mulou X1,X2,X3	multu RG2, RG3	mfhi X1	beq X1,X0, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow Unsigned : Set X1 to low-order 32 bits of the product of X2 and X3
mulou X1,X2,-100	addi X1, X0, VL3	multu RG2, X1	mfhi X1	beq X1,X0, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow Unsigned : Set X1 to low-order 32 bits of the product of X2 and signed 16-bit immediate
mulou X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	multu RG2, X1	mfhi X1	beq X1,X0, BROFF12	DBNOP	break	mflo RG1	#MULtiplication with Overflow Unsigned : Set X1 to low-order 32 bits of the product of X2 and 32-bit immediate
div X1,X2,X3	bne RG3, X0, BROFF12	DBNOP	break	div RG2, RG3	mflo RG1	#DIVision : Set X1 to (X2 divided by X3, integer division)
div X1,X2,-100	addi X1, X0, VL3	div RG2, X1	mflo RG1	#DIVision : Set X1 to (X2 divided by 16-bit immediate, integer division)
div X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	div RG2, X1	mflo RG1	#DIVision : Set X1 to (X2 divided by 32-bit immediate, integer division)
divu X1,X2,X3	bne RG3, X0, BROFF12	DBNOP	break	divu RG2, RG3	mflo RG1	#DIVision Unsigned :  Set X1 to (X2 divided by X3, unsigned integer division)
divu X1,X2,-100	addi X1, X0, VL3	divu RG2, X1	mflo RG1	#DIVision Unsigned :  Set X1 to (X2 divided by 16-bit immediate, unsigned integer division)
divu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	divu RG2, X1	mflo RG1	#DIVision Unsigned :  Set X1 to (X2 divided by 32-bit immediate, unsigned integer division)
rem X1,X2,X3	bne RG3, X0, BROFF12	DBNOP	break	div RG2, RG3	mfhi RG1	#REMainder : Set X1 to (remainder of X2 divided by X3)
rem X1,X2,-100	addi X1, X0, VL3	div RG2, X1	mfhi RG1	#REMainder : Set X1 to (remainder of X2 divided by 16-bit immediate)
rem X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	div RG2, X1	mfhi RG1	#REMainder : Set X1 to (remainder of X2 divided by 32-bit immediate)
remu X1,X2,X3	bne RG3, X0, BROFF12	DBNOP	break	divu RG2, RG3	mfhi RG1	#REMainder : Set X1 to (remainder of X2 divided by X3, unsigned division)
remu X1,X2,-100	addi X1, X0, VL3	divu RG2, X1	mfhi RG1	#REMainder : Set X1 to (remainder of X2 divided by 16-bit immediate, unsigned division)
remu X1,X2,100000	lui X1, VHL3	ori X1, X1, VL3U	divu RG2, X1	mfhi RG1	#REMainder : Set X1 to (remainder of X2 divided by 32-bit immediate, unsigned division)


#########################  load/store pseudo-ops start here  ##########################
#
#  Most of these simply provide a variety of convenient memory addressing modes for 
#  specifying load/store address.
#

li X1,-100	addiu RG1, X0, VL2	#Load Immediate : Set X1 to 16-bit immediate (sign-extended)
li X1,100	ori RG1, X0, VL2U	#Load Immediate : Set X1 to unsigned 16-bit immediate (zero-extended)
li X1,100000	lui X1, VHL2	ori RG1, X1, VL2U	#Load Immediate : Set X1 to 32-bit immediate

la X1,(X2)	addi RG1, RG3, 0	#Load Address : Set X1 to contents of X2
la X1,-100	addiu RG1, X0, VL2	#Load Address : Set X1 to 16-bit immediate (sign-extended) 
la X1,100	ori RG1, X0, VL2U	#Load Address : Set X1 to 16-bit immediate (zero-extended) 
la X1,100000	lui X1, VHL2	ori RG1, X1, VL2U	#Load Address : Set X1 to 32-bit immediate
la X1,100(X2)	ori X1, X0, VL2U	add RG1, RG4, X1	#Load Address : Set X1 to sum (of X2 and 16-bit immediate)
la X1,100000(X2)	lui X1, VHL2	ori X1, X1, VL2U	add RG1, RG4, X1	#Load Address : Set X1 to sum (of X2 and 32-bit immediate)
la X1,label	lui X1, LHL	ori RG1, X1, LL2U	COMPACT	addi RG1, X0, LL2	#Load Address : Set X1 to label's address
la X1,label(X2)	lui X1, LHL	ori X1, X1, LL2U	add RG1, RG4, X1	COMPACT	addi RG1, RG4, LL2	#Load Address : Set X1 to sum (of X2 and label's address)
la X1,label+100000	lui X1, LHPN	ori RG1, X1, LLPU	#Load Address : Set X1 to sum (of label's address and 32-bit immediate)
la X1,label+100000(X2)	lui X1, LHPN	ori X1, X1, LLPU	add RG1, RG6, X1	#Load Address : Set X1 to sum (of label's address, 32-bit immediate, and X2)

lw X1,(X2)	lw RG1,0(RG3)	#Load Word : Set X1 to contents of effective memory word address
lw X1,-100	lw RG1, VL2(X0)	#Load Word : Set X1 to contents of effective memory word address
lw X1,100	ori X1, X0, VL2U	lw RG1, 0(X1)	#Load Word : Set X1 to contents of effective memory word address
lw X1,100000	lui X1, VH2	lw RG1,VL2(X1)	#Load Word : Set X1 to contents of effective memory word address
lw X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	lw RG1, 0(X1)	#Load Word : Set X1 to contents of effective memory word address
lw X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lw RG1, VL2(X1)	#Load Word : Set X1 to contents of effective memory word address
lw X1,label	lui X1, LH2	lw RG1, LL2(X1)	COMPACT	lw RG1, LL2(X0)	#Load Word : Set X1 to contents of memory word at label's address
lw X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lw RG1, LL2(X1)	COMPACT	lw RG1, LL2(RG4)	#Load Word : Set X1 to contents of effective memory word address
lw X1,label+100000	lui X1, LHPA	lw RG1, LLP(X1)	#Load Word : Set X1 to contents of effective memory word address 
lw X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lw RG1, LLP(X1)	#Load Word : Set X1 to contents of effective memory word address

sw X1,(X2)	sw RG1,0(RG3)	#Store Word : Store X1 contents into effective memory word address
sw X1,-100	sw RG1, VL2(X0)	#Store Word : Store X1 contents into effective memory word address
sw X1,100	ori X1, X0, VL2U	sw RG1, 0(X1)	#Store Word : Store X1 contents into effective memory word address
sw X1,100000	lui X1, VH2	sw RG1,VL2(X1)	#Store Word : Store X1 contents into effective memory word address
sw X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	sw RG1, 0(X1)	#Store Word : Store X1 contents into effective memory word address
sw X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	sw RG1, VL2(X1)	#Store Word : Store X1 contents into effective memory word address
sw X1,label	lui X1, LH2	sw RG1, LL2(X1)	COMPACT	sw RG1, LL2(X0)	#Store Word : Store X1 contents into memory word at label's address
sw X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	sw RG1, LL2(X1)	COMPACT	sw RG1, LL2(RG4)	#Store Word : Store X1 contents into effective memory word address
sw X1,label+100000	lui X1, LHPA	sw RG1, LLP(X1)	#Store Word : Store X1 contents into effective memory word address
sw X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	sw RG1, LLP(X1)	#Store Word : Store X1 contents into effective memory word address

lh X1,(X2)	lh RG1,0(RG3)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,-100	lh RG1, VL2(X0)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,100	ori X1, X0, VL2U	lh RG1, 0(X1)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,100000	lui X1, VH2	lh RG1,VL2(X1)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	lh RG1, 0(X1)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lh RG1, VL2(X1)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,label	lui X1, LH2	lh RG1, LL2(X1)	COMPACT	lh RG1, LL2(X0)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lh RG1, LL2(X1)	COMPACT	lh RG1, LL2(RG4)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,label+100000	lui X1, LHPA	lh RG1, LLP(X1)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address
lh X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lh RG1, LLP(X1)	#Load Halfword : Set X1 to sign-extended 16-bit value from effective memory halfword address

sh X1,(X2)	sh RG1,0(RG3)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,-100	sh RG1, VL2(X0)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,100	ori X1, X0, VL2U	sh RG1, 0(X1)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,100000	lui X1, VH2	sh RG1,VL2(X1)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	sh RG1, 0(X1)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	sh RG1, VL2(X1)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,label	lui X1, LH2	sh RG1, LL2(X1)	COMPACT	sh RG1, LL2(X0)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	sh RG1, LL2(X1)	COMPACT	sh RG1, LL2(RG4)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,label+100000	lui X1, LHPA	sh RG1, LLP(X1)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address
sh X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	sh RG1, LLP(X1)	#Store Halfword : Store the low-order 16 bits of X1 into the effective memory halfword address

lb X1,(X2)	lb RG1,0(RG3)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,-100	lb RG1, VL2(X0)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,100	ori X1, X0, VL2U	lb RG1, 0(X1)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,100000	lui X1, VH2	lb RG1,VL2(X1)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	lb RG1, 0(X1)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lb RG1, VL2(X1)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,label	lui X1, LH2	lb RG1, LL2(X1)	COMPACT	lb RG1, LL2(X0)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lb RG1, LL2(X1)	COMPACT	lb RG1, LL2(RG4)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,label+100000	lui X1, LHPA	lb RG1, LLP(X1)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address
lb X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lb RG1, LLP(X1)	#Load Byte : Set X1 to sign-extended 8-bit value from effective memory byte address

sb X1,(X2)	sb RG1,0(RG3)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,-100	sb RG1, VL2(X0)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,100	ori X1, X0, VL2U	sb RG1, 0(X1)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,100000	lui X1, VH2	sb RG1,VL2(X1)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	sb RG1, 0(X1)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	sb RG1, VL2(X1)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,label	lui X1, LH2	sb RG1, LL2(X1)	COMPACT	sb RG1, LL2(X0)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	sb RG1, LL2(X1)	COMPACT	sb RG1, LL2(RG4)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,label+100000	lui X1, LHPA	sb RG1, LLP(X1)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address
sb X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	sb RG1, LLP(X1)	#Store Byte : Store the low-order 8 bits of X1 into the effective memory byte address

lhu X1,(X2)	lhu RG1,0(RG3)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,-100	lhu RG1,VL2(X0)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,100	ori X1, X0, VL2U	lhu RG1, 0(X1)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,100000	lui X1, VH2	lhu RG1,VL2(X1)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	lhu RG1, 0(X1)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lhu RG1, VL2(X1)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,label	lui X1, LH2	lhu RG1, LL2(X1)	COMPACT	lhu RG1, LL2(X0)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lhu RG1, LL2(X1)	COMPACT	lhu RG1, LL2(RG4)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,label+100000	lui X1, LHPA	lhu RG1, LLP(X1)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address
lhu X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lhu RG1, LLP(X1)	#Load Halfword Unsigned : Set X1 to zero-extended 16-bit value from effective memory halfword address

lbu X1,(X2)	lbu RG1,0(RG3)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,-100	lbu RG1,VL2(X0)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,100	ori X1, X0, VL2U	lbu RG1, 0(X1)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,100000	lui X1, VH2	lbu RG1,VL2(X1)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	lbu RG1, 0(X1)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lbu RG1, VL2(X1)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,label	lui X1, LH2	lbu RG1, LL2(X1)	COMPACT	lbu RG1, LL2(X0)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lbu RG1, LL2(X1)	COMPACT	lbu RG1, LL2(RG4)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,label+100000	lui X1, LHPA	lbu RG1, LLP(X1)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address
lbu X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lbu RG1, LLP(X1)	#Load Byte Unsigned : Set X1 to zero-extended 8-bit value from effective memory byte address

lwl X1,(X2)	lwl RG1,0(RG3)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,-100	lwl RG1,VL2(X0)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,100	ori X1, X0, VL2U	lwl RG1, 0(X1)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,100000	lui X1, VH2	lwl RG1,VL2(X1)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	lwl RG1, 0(X1)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lwl RG1, VL2(X1)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,label	lui X1, LH2	lwl RG1, LL2(X1)	COMPACT	lwl RG1, LL2(X0)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lwl RG1, LL2(X1)	COMPACT	lwl RG1, LL2(RG4)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,label+100000	lui X1, LHPA	lwl RG1, LLP(X1)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word
lwl X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lwl RG1, LLP(X1)	#Load Word Left : Load from 1 to 4 bytes left-justified into X1, starting with effective memory byte address and continuing through the low-order byte of its word

swl X1,(X2)	swl RG1,0(RG3)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,-100	swl RG1,VL2(X0)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,100	ori X1, X0, VL2U	swl RG1, 0(X1)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,100000	lui X1, VH2	swl RG1,VL2(X1)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	swl RG1, 0(X1)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	swl RG1, VL2(X1)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,label	lui X1, LH2	swl RG1, LL2(X1)	COMPACT	swl RG1, LL2(X0)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	swl RG1, LL2(X1)	COMPACT	swl RG1, LL2(RG4)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,label+100000	lui X1, LHPA	swl RG1, LLP(X1)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word
swl X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	swl RG1, LLP(X1)	#Store Word Left : Store high-order 1 to 4 bytes of X1 into memory, starting with effective memory byte address and continuing through the low-order byte of its word

lwr X1,(X2)	lwr RG1,0(RG3)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,-100	lwr RG1,VL2(X0)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,100	ori X1, X0, VL2U	lwr RG1, 0(X1)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,100000	lui X1, VH2	lwr RG1,VL2(X1)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	lwr RG1, 0(X1)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lwr RG1, VL2(X1)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,label	lui X1, LH2	lwr RG1, LL2(X1)	COMPACT	lwr RG1, LL2(X0)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lwr RG1, LL2(X1)	COMPACT	lwr RG1, LL2(RG4)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,label+100000	lui X1, LHPA	lwr RG1, LLP(X1)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word
lwr X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lwr RG1, LLP(X1)	#Load Word Right : Load from 1 to 4 bytes right-justified into X1, starting with effective memory byte address and continuing through the high-order byte of its word

swr X1,(X2)	swr RG1,0(RG3)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,-100	swr RG1,VL2(X0)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,100	ori X1, X0, VL2U	swr RG1, 0	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,100000	lui X1, VH2	swr RG1,VL2(X1)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	swr RG1, 0(X1)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	swr RG1, VL2(X1)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,label	lui X1, LH2	swr RG1, LL2(X1)	COMPACT	swr RG1, LL2(X0)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	swr RG1, LL2(X1)	COMPACT	swr RG1, LL2(RG4)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,label+100000	lui X1, LHPA	swr RG1, LLP(X1)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address
swr X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	swr RG1, LLP(X1)	#Store Word Right : Store low-order 1 to 4 bytes of X1 into memory, starting with high-order byte of word containing effective memory byte address and continuing through that byte address

ll X1,(X2)	ll RG1,0(RG3)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,-100	ll RG1,VL2(X0)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,100	ori X1, X0, VL2U	ll RG1, 0(X1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,100000	lui X1, VH2	ll RG1,VL2(X1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	ll RG1, 0(X1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	ll RG1, VL2(X1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,label	lui X1, LH2	ll RG1, LL2(X1)	COMPACT	ll RG1, LL2(X0)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	ll RG1, LL2(X1)	COMPACT	ll RG1, LL2(RG4)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,label+100000	lui X1, LHPA	ll RG1, LLP(X1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.
ll X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	ll RG1, LLP(X1)	#Load Linked : Paired with Store Conditional (sc) to perform atomic read-modify-write.  Treated as equivalent to Load Word (lw) because MARS does not simulate multiple processors.

sc X1,(X2)	sc RG1,0(RG3)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,-100	sc RG1,VL2(X0)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,100	ori X1, X0, VL2U	sc RG1, 0(X1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,100000	lui X1, VH2	sc RG1,VL2(X1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,100(X2)	ori X1, X0, VL2U	addu X1, X1, RG4	sc RG1, 0(X1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	sc RG1, VL2(X1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,label	lui X1, LH2	sc RG1, LL2(X1)	COMPACT	sc RG1, LL2(X0)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	sc RG1, LL2(X1)	COMPACT	sc RG1, LL2(RG4)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,label+100000	lui X1, LHPA	sc RG1, LLP(X1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.
sc X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	sc RG1, LLP(X1)	#Store Conditional : Paired with Load Linked (ll) to perform atomic read-modify-write.  Treated as equivalent to Store Word (sw) because MARS does not simulate multiple processors.

# Unaligned and double loads and stores.  All the them require assembler to add a constant
# byte offset (from 1 to 4 bytes) to the given or calculated address.
# NOTE: I have abandoned the "accepted" expansion of immed16($reg) addressing form for the 
#       unaligned and double load/store pseudo-instructions because they produce what I consider 
#       incorrect results for immediate values at the upper edge of the signed 16-bit range 
#       (32765 through 32767).  The expansion of these pseudo's requires adding an additional 
#       byte offset (from 1 to 4 bytes) to the immediate value, which overflows the signed 16 
#       bit range and results in a large negative offset with no counterbalancing increment 
#       to the high order 16-bits.  Thus if the two pieces of unaligned data end up in different 
#       words, they are stored 64K bytes apart!  For example, the normal expansion of 
#       "usw X8,32767(X9)" would be "swl X8,-32766(X9)", "swr X8, 32767(X9)"  Both SPIM and
#       Britten's text do this but I consider it incorrect.  My compromise is the following:
#       since each of the expansion calls for two calculated offsets, one of which can possibly
#       overflow due to the addition but the other will not (because there is no addition),
#       I'll code the expansion to treat the at-risk calculated offset as 32-bits (it will generate
#       the lui and addu, which is unnecessary in almost every case but is always correct)
#       and the second as 16-bits.  I'll group all instructions for this addressing mode together.
# ulw X1,-100(X2)	lwl RG1, VL2P3(RG4)	lwr RG1, VL2(RG4)   -- used by SPIM but not me.
# usw X1,-100(X2)	swl RG1, VL2P3(RG4)	swr RG1, VL2(RG4)   -- used by SPIM but not me.

ulw X1,-100(X2)	lui X1, VH2P3	addu X1, X1, RG4	lwl RG1, VL2P3(X1)	lwr RG1, VL2(RG4)	#Unaligned Load Word : Set X1 to the 32 bits starting at effective memory byte address
ulh X1,-100(X2)	lui X1, VH2P1	addu X1, X1, RG4	lb RG1, VL2P1(X1)	lbu X1, VL2(RG4)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, sign-extended, starting at effective memory byte address
ulhu X1,-100(X2)	lui X1, VH2P1	addu X1, X1, RG4	lbu RG1, VL2P1(X1)	lbu X1, VL2(RG4)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, zero-extended, starting at effective memory byte address
ld X1,-100(X2)	lw RG1, VL2(RG4)	lui X1, VH2P4	addu X1, X1, RG4	lw NR1, VL2P4(X1)	#Load Doubleword : Set X1 and the next register to the 64 bits starting at effective memory byte address
usw X1,-100(X2)	lui X1, VH2P3	addu X1, X1, RG4	swl RG1, VL2P3(X1)	swr RG1, VL2(RG4)	#Unaligned Store Word : Store X1 contents into the 32 bits starting at effective memory byte address
ush X1,-100(X2)	sb RG1, VL2(RG4)	sll X1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, X1	lui X1, VH2P1	addu X1, X1, RG4	sb RG1, VL2P1(X1)	srl X1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Store Halfword: Store low-order halfword X1 contents into the 16 bits starting at effective memory byte address
sd X1,-100(X2)	sw RG1, VL2(RG4)	lui X1, VH2P4	addu X1, X1, RG4	sw NR1, VL2P4(X1)	#Store Doubleword : Store contents of X1 and the next register to the 64 bits starting at effective memory byte address

# here are the remaining addressing modes, grouped by instruction.

ulw X1,100000	lui X1, VH2P3	lwl RG1, VL2P3(X1)	lui X1, VH2	lwr RG1, VL2(X1)	#Unaligned Load Word : Set X1 to the 32 bits starting at effective memory byte address
ulw X1,label	lui X1, LH2P3	lwl RG1, LL2P3(X1)	lui X1, LH2	lwr RG1, LL2(X1)	#Unaligned Load Word : Set X1 to the 32 bits starting at effective memory byte address
ulw X1,label+100000	lui X1, LHPAP3	lwl RG1, LLPP3(X1)	lui X1, LHPA	lwr RG1, LLP(X1)	#Unaligned Load Word : Set X1 to the 32 bits starting at effective memory byte address
ulw X1,(X2)	lwl RG1, 3(RG3)	lwr RG1, 0(RG3)	#Unaligned Load Word : Set X1 to the 32 bits starting at effective memory byte address
ulw X1,100000(X2)	lui X1, VH2P3	addu X1, X1, RG4	lwl RG1, VL2P3(X1)	lui X1, VH2	addu X1, X1, RG4	lwr RG1, VL2(X1)	#Unaligned Load Word : Set X1 to the 32 bits starting at effective memory byte address
ulw X1,label(X2)	lui X1, LH2P3	addu X1, X1, RG4	lwl RG1, LL2P3(X1)	lui X1, LH2	addu X1, X1, RG4	lwr RG1, LL2(X1)	#Unaligned Load Word : Set X1 to the 32 bits starting at effective memory byte address
ulw X1,label+100000(X2)	lui X1, LHPAP3	addu X1, X1, RG6	lwl RG1, LLPP3(X1)	lui X1, LHPA	addu X1, X1, RG6	lwr RG1, LLP(X1)	#Unaligned Load Word : Set X1 to the 32 bits starting at effective memory byte address

ulh X1,100000	lui X1, VH2P1	lb RG1, VL2P1(X1)	lui X1, VH2	lbu X1, VL2(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh X1,label	lui X1, LH2P1	lb RG1, LL2P1(X1)	lui X1, LH2	lbu X1, LL2(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh X1,label+100000	lui X1, LHPAP1	lb RG1, LLPP1(X1)	lui X1, LHPA	lbu X1, LLP(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh X1,(X2)	lb RG1, 1(RG3)	lbu X1, 0(RG3)	sll RG1, RG1, 8	or RG1, RG1, X1		#Unaligned Load Halfword : Set X1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh X1,100000(X2)	lui X1, VH2P1	addu X1, X1, RG4	lb RG1, VL2P1(X1)	lui X1, VH2	addu X1, X1, RG4	lbu X1, VL2(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh X1,label(X2)	lui X1, LH2P1	addu X1, X1, RG4	lb RG1, LL2P1(X1)	lui X1, LH2	addu X1, X1, RG4	lbu X1, LL2(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, sign-extended, starting at effective memory byte address
ulh X1,label+100000(X2)	lui X1, LHPAP1	addu X1, X1, RG6	lb RG1, LLPP1(X1)	lui X1, LHPA	addu X1, X1, RG6	lbu X1, LLP(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, sign-extended, starting at effective memory byte address

ulhu X1,100000	lui X1, VH2P1	lbu RG1, VL2P1(X1)	lui X1, VH2	lbu X1, VL2(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu X1,label	lui X1, LH2P1	lbu RG1, LL2P1(X1)	lui X1, LH2	lbu X1, LL2(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu X1,label+100000	lui X1, LHPAP1	lbu RG1, LLPP1(X1)	lui X1, LHPA	lbu X1, LLP(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu X1,(X2)	lbu RG1, 1(RG3)	lbu X1, 0(RG3)	sll RG1, RG1, 8	or RG1, RG1, X1		#Unaligned Load Halfword : Set X1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu X1,100000(X2)	lui X1, VH2P1	addu X1, X1, RG4	lbu RG1, VL2P1(X1)	lui X1, VH2	addu X1, X1, RG4	lbu X1, VL2(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu X1,label(X2)	lui X1, LH2P1	addu X1, X1, RG4	lbu RG1, LL2P1(X1)	lui X1, LH2	addu X1, X1, RG4	lbu X1, LL2(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, zero-extended, starting at effective memory byte address
ulhu X1,label+100000(X2)	lui X1, LHPAP1	addu X1, X1, RG6	lbu RG1, LLPP1(X1)	lui X1, LHPA	addu X1, X1, RG6	lbu X1, LLP(X1)	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Load Halfword : Set X1 to the 16 bits, zero-extended, starting at effective memory byte address

ld X1,100000	lui X1, VH2	lw RG1, VL2(X1)	lui X1, VH2P4	lw NR1, VL2P4(X1)	#Load Doubleword : Set X1 and the next register to the 64 bits starting at effective memory word address
ld X1,label	lui X1, LH2	lw RG1, LL2(X1)	lui X1, LH2P4	lw NR1, LL2P4(X1)	#Load Doubleword : Set X1 and the next register to the 64 bits starting at effective memory word address
ld X1,label+100000	lui X1, LHPA	lw RG1, LLP(X1)	lui X1, LHPAP4	lw NR1, LLPP4(X1)	#Load Doubleword : Set X1 and the next register to the 64 bits starting at effective memory word address
ld X1,(X2)	lw RG1, 0(RG3)	lw NR1, 4(RG3)	#Load Doubleword : Set X1 and the next register to the 64 bits starting at effective memory word address
ld X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lw RG1, VL2(X1)	lui X1, VH2P4	addu X1, X1, RG4	lw NR1, VL2P4(X1)	#Load Doubleword : Set X1 and the next register to the 64 bits starting at effective memory word address
ld X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lw RG1, LL2(X1)	lui X1, LH2P4	addu X1, X1, RG4	lw NR1, LL2P4(X1)	#Load Doubleword : Set X1 and the next register to the 64 bits starting at effective memory word address
ld X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lw RG1, LLP(X1)	lui X1, LHPAP4	addu X1, X1, RG6	lw NR1, LLPP4(X1)	#Load Doubleword : Set X1 and the next register to the 64 bits starting at effective memory word address

usw X1,100000	lui X1, VH2P3	swl RG1, VL2P3(X1)	lui X1, VH2	swr RG1, VL2(X1)	#Unaligned Store Word : Store X1 contents into the 32 bits starting at effective memory byte address
usw X1,label	lui X1, LH2P3	swl RG1, LL2P3(X1)	lui X1, LH2	swr RG1, LL2(X1)	#Unaligned Store Word : Store X1 contents into the 32 bits starting at effective memory byte address
usw X1,label+100000	lui X1, LHPAP3	swl RG1, LLPP3(X1)	lui X1, LHPA	swr RG1, LLP(X1)	#Unaligned Store Word : Store X1 contents into the 32 bits starting at effective memory byte address
usw X1,(X2)	swl RG1, 3(RG3)	swr RG1, 0(RG3)	#Unaligned Store Word : Store X1 contents into the 32 bits starting at effective memory byte address
usw X1,100000(X2)	lui X1, VH2P3	addu X1, X1, RG4	swl RG1, VL2P3(X1)	lui X1, VH2	addu X1, X1, RG4	swr RG1, VL2(X1)	#Unaligned Store Word : Store X1 contents into the 32 bits starting at effective memory byte address
usw X1,label(X2)	lui X1, LH2P3	addu X1, X1, RG4	swl RG1, LL2P3(X1)	lui X1, LH2	addu X1, X1, RG4	swr RG1, LL2(X1)	#Unaligned Store Word : Store X1 contents into the 32 bits starting at effective memory byte address
usw X1,label+100000(X2)	lui X1, LHPAP3	addu X1, X1, RG6	swl RG1, LLPP3(X1)	lui X1, LHPA	addu X1, X1, RG6	swr RG1, LLP(X1)	#Unaligned Store Word : Store X1 contents into the 32 bits starting at effective memory byte address

ush X1,100000	lui X1, VH2	sb RG1, VL2(X1)	sll X1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, X1	lui X1, VH2P1	sb RG1, VL2P1(X1)	srl X1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Store Halfword: Store low-order halfword X1 contents into the 16 bits starting at effective memory byte address
ush X1,label	lui X1, LH2	sb RG1, LL2(X1)	sll X1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, X1	lui X1, LH2P1	sb RG1, LL2P1(X1)	srl X1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Store Halfword: Store low-order halfword X1 contents into the 16 bits starting at effective memory byte address
ush X1,label+100000	lui X1, LHPA	sb RG1, LLP(X1)	sll X1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, X1	lui X1, LHPAP1	sb RG1, LLPP1(X1)	srl X1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Store Halfword: Store low-order halfword X1 contents into the 16 bits starting at effective memory byte address
ush X1,(X2)	sb RG1, 0(RG3)	sll X1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, X1	sb RG1, 1(RG3)	srl X1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Store Halfword: Store low-order halfword X1 contents into the 16 bits starting at effective memory byte address
ush X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	sb RG1, VL2(X1)	sll X1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, X1	lui X1, VH2P1	addu X1, X1, RG4	sb RG1, VL2P1(X1)	srl X1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Store Halfword: Store low-order halfword X1 contents into the 16 bits starting at effective memory byte address
ush X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	sb RG1, LL2(X1)	sll X1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, X1	lui X1, LH2P1	addu X1, X1, RG4	sb RG1, LL2P1(X1)	srl X1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Store Halfword: Store low-order halfword X1 contents into the 16 bits starting at effective memory byte address
ush X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	sb RG1, LLP(X1)	sll X1, RG1, 24	srl RG1, RG1, 8	or RG1, RG1, X1	lui X1, LHPAP1	addu X1, X1, RG6	sb RG1, LLPP1(X1)	srl X1, RG1, 24	sll RG1, RG1, 8	or RG1, RG1, X1	#Unaligned Store Halfword: Store low-order halfword X1 contents into the 16 bits starting at effective memory byte address

sd X1,100000	lui X1, VH2	sw RG1, VL2(X1)	lui X1, VH2P4	sw NR1, VL2P4(X1)	#Store Doubleword : Store contents of X1 and the next register to the 64 bits starting at effective memory word address
sd X1,label	lui X1, LH2	sw RG1, LL2(X1)	lui X1, LH2P4	sw NR1, LL2P4(X1)	#Store Doubleword : Store contents of X1 and the next register to the 64 bits starting at effective memory word address
sd X1,label+100000	lui X1, LHPA	sw RG1, LLP(X1)	lui X1, LHPAP4	sw NR1, LLPP4(X1)	#Store Doubleword : Store contents of X1 and the next register to the 64 bits starting at effective memory word address
sd X1,(X2)	sw RG1, 0(RG3)	sw NR1, 4(RG3)	#Store Doubleword : Store contents of X1 and the next register to the 64 bits starting at effective memory word address
sd X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	sw RG1, VL2(X1)	lui X1, VH2P4	addu X1, X1, RG4	sw NR1, VL2P4(X1)	#Store Doubleword : Store contents of X1 and the next register to the 64 bits starting at effective memory word address
sd X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	sw RG1, LL2(X1)	lui X1, LH2P4	addu X1, X1, RG4	sw NR1, LL2P4(X1)	#Store Doubleword : Store contents of X1 and the next register to the 64 bits starting at effective memory word address
sd X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	sw RG1, LLP(X1)	lui X1, LHPAP4	addu X1, X1, RG6	sw NR1, LLPP4(X1)	#Store Doubleword : Store contents of X1 and the next register to the 64 bits starting at effective memory word address

# load and store pseudo-instructions for floating point (coprocessor 1) registers

lwc1 X1,(X2)	lwc1 RG1,0(RG3)	#Load Word Coprocessor 1 : Set X1 to 32-bit value from effective memory word address
lwc1 X1,-100	lwc1 RG1,VL2(X0)	#Load Word Coprocessor 1 : Set X1 to 32-bit value from effective memory word address
lwc1 X1,100000	lui X1, VH2	lwc1 RG1,VL2(X1)	#Load Word Coprocessor 1 : Set X1 to 32-bit value from effective memory word address
lwc1 X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lwc1 RG1, VL2(X1)	#Load Word Coprocessor 1 : Set X1 to 32-bit value from effective memory word address
lwc1 X1,label	lui X1, LH2	lwc1 RG1, LL2(X1)	COMPACT	lwc1 RG1, LL2(X0)	#Load Word Coprocessor 1 : Set X1 to 32-bit value from effective memory word address
lwc1 X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lwc1 RG1, LL2(X1)	COMPACT	lwc1 RG1, LL2(RG4)	#Load Word Coprocessor 1 : Set X1 to 32-bit value from effective memory word address
lwc1 X1,label+100000	lui X1, LHPA	lwc1 RG1, LLP(X1)	#Load Word Coprocessor 1 : Set X1 to 32-bit value from effective memory word address
lwc1 X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lwc1 RG1, LLP(X1)	#Load Word Coprocessor 1 : Set X1 to 32-bit value from effective memory word address

ldc1 X2,(X2)	ldc1 RG1,0(RG3)	#Load Doubleword Coprocessor 1 : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
ldc1 X2,-100	ldc1 RG1,VL2(X0)	#Load Doubleword Coprocessor 1 : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
ldc1 X2,100000	lui X1, VH2	ldc1 RG1,VL2(X1)	#Load Doubleword Coprocessor 1 : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
ldc1 X2,100000(X2)	lui X1, VH2	addu X1, X1, RG4	ldc1 RG1, VL2(X1)	#Load Doubleword Coprocessor 1 : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
ldc1 X2,label	lui X1, LH2	ldc1 RG1, LL2(X1)	COMPACT	ldc1 RG1, LL2(X0)	#Load Doubleword Coprocessor 1 : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
ldc1 X2,label(X2)	lui X1, LH2	addu X1, X1, RG4	ldc1 RG1, LL2(X1)	COMPACT	ldc1 RG1, LL2(RG4)	#Load Doubleword Coprocessor 1 : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
ldc1 X2,label+100000	lui X1, LHPA	ldc1 RG1, LLP(X1)	#Load Doubleword Coprocessor 1 : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
ldc1 X2,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	ldc1 RG1, LLP(X1)	#Load Doubleword Coprocessor 1 : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address

swc1 X1,(X2)	swc1 RG1,0(RG3)	#Store Word Coprocessor 1 : Store 32-bit value from X1 to effective memory word address
swc1 X1,-100	swc1 RG1,VL2(X0)	#Store Word Coprocessor 1 : Store 32-bit value from X1 to effective memory word address
swc1 X1,100000	lui X1, VH2	swc1 RG1,VL2(X1)	#Store Word Coprocessor 1 : Store 32-bit value from X1 to effective memory word address
swc1 X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	swc1 RG1, VL2(X1)	#Store Word Coprocessor 1 : Store 32-bit value from X1 to effective memory word address
swc1 X1,label	lui X1, LH2	swc1 RG1, LL2(X1)	COMPACT	swc1 RG1, LL2(X0)	#Store Word Coprocessor 1 : Store 32-bit value from X1 to effective memory word address
swc1 X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	swc1 RG1, LL2(X1)	COMPACT	swc1 RG1, LL2(RG4)	#Store Word Coprocessor 1 : Store 32-bit value from X1 to effective memory word address
swc1 X1,label+100000	lui X1, LHPA	swc1 RG1, LLP(X1)	#Store Word Coprocessor 1 : Store 32-bit value from X1 to effective memory word address
swc1 X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	swc1 RG1, LLP(X1)	#Store Word Coprocessor 1 : Store 32-bit value from X1 to effective memory word address

sdc1 X2,(X2)	sdc1 RG1,0(RG3)	#Store Doubleword Coprocessor 1 : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
sdc1 X2,-100	sdc1 RG1,VL2(X0)	#Store Doubleword Coprocessor 1 : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
sdc1 X2,100000	lui X1, VH2	sdc1 RG1,VL2(X1)	#Store Doubleword Coprocessor 1 : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
sdc1 X2,100000(X2)	lui X1, VH2	addu X1, X1, RG4	sdc1 RG1, VL2(X1)	#Store Doubleword Coprocessor 1 : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
sdc1 X2,label	lui X1, LH2	sdc1 RG1, LL2(X1)	COMPACT	sdc1 RG1, LL2(X0)	#Store Doubleword Coprocessor 1 : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
sdc1 X2,label(X2)	lui X1, LH2	addu X1, X1, RG4	sdc1 RG1, LL2(X1)	COMPACT	sdc1 RG1, LL2(RG4)	#Store Doubleword Coprocessor 1 : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
sdc1 X2,label+100000	lui X1, LHPA	sdc1 RG1, LLP(X1)	#Store Doubleword Coprocessor 1 : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
sdc1 X2,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	sdc1 RG1, LLP(X1)	#Store Doubleword Coprocessor 1 : Store 64 bits from X2 and X3 register pair to effective memory doubleword address

l.s X1,(X2)	lwc1 RG1,0(RG3)	#Load floating point Single precision : Set X1 to 32-bit value at effective memory word address
l.s X1,-100	lwc1 RG1,VL2(X0)	#Load floating point Single precision : Set X1 to 32-bit value at effective memory word address
l.s X1,100000	lui X1, VH2	lwc1 RG1,VL2(X1)	#Load floating point Single precision : Set X1 to 32-bit value at effective memory word address
l.s X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	lwc1 RG1, VL2(X1)	#Load floating point Single precision : Set X1 to 32-bit value at effective memory word address
l.s X1,label	lui X1, LH2	lwc1 RG1, LL2(X1)	COMPACT	lwc1 RG1, LL2(X0)	#Load floating point Single precision : Set X1 to 32-bit value at effective memory word address
l.s X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	lwc1 RG1, LL2(X1)	COMPACT	lwc1 RG1, LL2(RG4)	#Load floating point Single precision : Set X1 to 32-bit value at effective memory word address
l.s X1,label+100000	lui X1, LHPA	lwc1 RG1, LLP(X1)	#Load floating point Single precision : Set X1 to 32-bit value at effective memory word address
l.s X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	lwc1 RG1, LLP(X1)	#Load floating point Single precision : Set X1 to 32-bit value at effective memory word address

s.s X1,(X2)	swc1 RG1,0(RG3)	#Store floating point Single precision : Store 32-bit value from X1 to effective memory word address
s.s X1,-100	swc1 RG1,VL2(X0)	#Store floating point Single precision : Store 32-bit value from X1 to effective memory word address
s.s X1,100000	lui X1, VH2	swc1 RG1,VL2(X1)	#Store floating point Single precision : Store 32-bit value from X1 to effective memory word address
s.s X1,100000(X2)	lui X1, VH2	addu X1, X1, RG4	swc1 RG1, VL2(X1)	#Store floating point Single precision : Store 32-bit value from X1 to effective memory word address
s.s X1,label	lui X1, LH2	swc1 RG1, LL2(X1)	COMPACT	swc1 RG1, LL2(X0)	#Store floating point Single precision : Store 32-bit value from X1 to effective memory word address
s.s X1,label(X2)	lui X1, LH2	addu X1, X1, RG4	swc1 RG1, LL2(X1)	COMPACT	swc1 RG1, LL2(RG4)	#Store floating point Single precision : Store 32-bit value from X1 to effective memory word address
s.s X1,label+100000	lui X1, LHPA	swc1 RG1, LLP(X1)	#Store floating point Single precision : Store 32-bit value from X1 to effective memory word address
s.s X1,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	swc1 RG1, LLP(X1)	#Store floating point Single precision : Store 32-bit value from X1 to effective memory word address

l.d X2,(X2)	ldc1 RG1,0(RG3)	#Load floating point Double precision : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
l.d X2,-100	ldc1 RG1,VL2(X0)	#Load floating point Double precision : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
l.d X2,100000	lui X1, VH2	ldc1 RG1,VL2(X1)	#Load floating point Double precision : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
l.d X2,100000(X2)	lui X1, VH2	addu X1, X1, RG4	ldc1 RG1, VL2(X1)	#Load floating point Double precision : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
l.d X2,label	lui X1, LH2	ldc1 RG1, LL2(X1)	COMPACT	ldc1 RG1, LL2(X0)	#Load floating point Double precision : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
l.d X2,label(X2)	lui X1, LH2	addu X1, X1, RG4	ldc1 RG1, LL2(X1)	COMPACT	ldc1 RG1, LL2(RG4)	#Load floating point Double precision : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
l.d X2,label+100000	lui X1, LHPA	ldc1 RG1, LLP(X1)	#Load floating point Double precision : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address
l.d X2,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	ldc1 RG1, LLP(X1)	#Load floating point Double precision : Set X2 and X3 register pair to 64-bit value at effective memory doubleword address

s.d X2,(X2)	sdc1 RG1,0(RG3)	#Store floating point Double precision : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
s.d X2,-100	sdc1 RG1,VL2(X0)	#Store floating point Double precision : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
s.d X2,100000	lui X1, VH2	sdc1 RG1,VL2(X1)	#Store floating point Double precision : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
s.d X2,100000(X2)	lui X1, VH2	addu X1, X1, RG4	sdc1 RG1, VL2(X1)	#Store floating point Double precision : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
s.d X2,label	lui X1, LH2	sdc1 RG1, LL2(X1)	COMPACT	sdc1 RG1, LL2(X0)	#Store floating point Double precision : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
s.d X2,label(X2)	lui X1, LH2	addu X1, X1, RG4	sdc1 RG1, LL2(X1)	COMPACT	sdc1 RG1, LL2(RG4)	#Store floating point Double precision : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
s.d X2,label+100000	lui X1, LHPA	sdc1 RG1, LLP(X1)	#Store floating point Double precision : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
s.d X2,label+100000(X2)	lui X1, LHPA	addu X1, X1, RG6	sdc1 RG1, LLP(X1)	#Store floating point Double precision : Store 64 bits from X2 and X3 register pair to effective memory doubleword address
